= Chapter 2: Modules Separation: Focus On Maintainability
:toc:

== Case

=== Overview

After the initial steps - while building the MVP of the application - the codebase starts to get bigger and more complicated.

Imagine that you started developing your application with a similar approach as in the first chapter - with only 1 production code project. It was successful, got more and more traction in the market, and therefore a lot of customers. In addition, together with the development team, you introduce new features and therefore:

1. Each module grows.
2. Some modules change more often than others.
3. New teams are created. Now there are 3 different teams working on features within one project. It becomes harder to maintain - teams touch the same areas, there are a lot of conflicts.
4. You notice that some modules are typical CRUD modules and some are very complex.

It makes sense to start splitting a production project into a set of projects per domain. 

NOTE: This step makes the codebase much larger than before. Think twice before deciding to do this.

IMPORTANT: To keep the code simple and understandable while comparing it to the first chapter, we have not added any new features (business processes). Thanks to this, you can see how complex the code structure is compared to the previous one.

=== Requirements

As mentioned in the overview, the requirements remain unchanged to keep the codebase comparable to the previous step. We will continue to do this throughout the chapters.

=== Main assumptions

Due to changing requirements and the current market situation (here you have to imagine that this is the case, although we do not assume any new requirements), we have to adjust our assumptions:

1. Our application is used by 5000 people (the upper limit of our first assumptions from the MVP). It still makes no sense to extract parts of the application into microservices, so we keep our modular monolith and scale it as a single deployment unit (here we can use e.g. a load balancer - please remember that we do not cover infrastructure topics in this repo).
2. A lot of new features will be added to our solution. There are many requests from our customers and after considering them, we usually decide to implement them. We also decide to add some features on our own based on analytics observations.
3. Parts of the application change extremely quickly - several times a day.
4. The _Contracts_ module is becoming increasingly complex due to new business logic.
5. We have several development teams and they start complaining about conflicts they have while working with the code and touching the same areas.

=== Solution

==== Overview

==== Solution structure

==== Communication

==== Tests

==== Miscellaneous

== How to Run?

=== Requirements
- .NET SDK
- PostgresSQL
- Docker

=== How to get .NET SDK?

To run the Fitnet application, you will need to have the recent .NET SDK installed on your computer.
Click link:https://dotnet.microsoft.com/en-us/download[here] 
to download it from the official Microsoft website.

=== How to prepare Postgres?

The Fitnet application requires PostgresSQL as a component to work properly. You can either install it directly on your system or launch it using Docker Compose.

To run PostgresSQL using Docker Compose, navigate to the `root` chapter directory using the Terminal and run the command:
1. Build the Docker compose:

[source,shell]
----
 docker-compose up
----

This will start the PostgresSQL service. Once Postgres is up and running, you can proceed to run the Fitnet application.

=== Run the Fitnet Application

There are two options to run the Fitnet application:

==== Option 1: Launch the Fitnet application in an IDE

If you have an IDE installed, you can launch the Fitnet application directly from there by following these steps:

1. Open the project in your IDE.
2. Run the project.
3. The Fitnet application should start running.

[NOTE]
Fitnet supports .NET User Secrets to store local secrets like connection strings on developer machine. 
We encourage you to use this feature to securely store the connection string.
[end]

==== Option 2: Build and run the Fitnet application as a Docker container

If you prefer to run the Fitnet application as a Docker container, you can build and run it using the following steps:

1. Build the Docker image:

[source,shell]
----
docker build -t fitnet .
----

2. Run the Docker container:
[source,shell]
----
docker run -p 8080:80 --name fitnet-container fitnet
----

The "8080" is the port number on which the container will be exposed, and "myapp" is the name of the image that you built in the previous step. Once the container is up and running, you should be able to access the application by navigating to http://localhost:8080 in your web browser.

That's it! You should now be able to run the application using either one of the above. :thumbsup:

=== How to run Integration Tests?
To run the integration tests for the project located in the Fitnet.IntegrationTests project, you can use either the command:
[source,shell]
----
dotnet test
----
or the `IDE test Explorer`. 

These tests are written using `xUnit` and require `Docker` to be running as they use `test containers` package to run PostgresSQL in a Docker container during testing. 
Therefore, make sure to have `Docker` running before executing the integration tests.